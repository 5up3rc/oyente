import re

class Vulnerability:
    def __init__(self, source_map, pcs):
        self.source_map = source_map
        self.pcs = self._rm_general_false_positives(pcs)

    def is_vulnerable(self):
        return bool(self.pcs)

    def _rm_general_false_positives(self, pcs):
        new_pcs = pcs
        if self.source_map:
            new_pcs = self._rm_pcs_having_no_source_code(new_pcs)
            new_pcs = self._reduce_pcs_having_the_same_pos(new_pcs)
        return new_pcs

    def _rm_pcs_having_no_source_code(self, pcs):
        return [pc for pc in pcs if self.source_map.find_source_code(pc)]

    def _reduce_pcs_having_the_same_pos(self, pcs):
        d = {}
        for pc in pcs:
            pos = str(self.source_map.instr_positions[pc])
            if pos not in d:
                d[pos] = pc
        return d.values()

    def __str__(self, vul_name):
        s = ''
        for pc in self.pcs:
            source_code = self.source_map.find_source_code(pc)
            if not source_code:
                continue

            new_line_idx = source_code.find('\n')
            source_code = source_code.split('\n')[0]
            location = self.source_map.get_location(pc)

            source = re.sub(self.source_map.root_path, '', self.source_map.get_filename())
            line = location['begin']['line'] + 1
            column = location['begin']['column'] + 1
            s += '%s:%s:%s: Warning: %s.\n' % (source, line, column, vul_name)
            s += source_code
            if new_line_idx != -1:
                s += '\n' + self._leading_spaces(source_code) + '^\n'
                s += 'Spanning multiple lines.'
        return s

    def _leading_spaces(self, s):
        stripped_s = s.lstrip('[ \t]')
        len_of_leading_spaces = len(s) - len(stripped_s)
        return s[0:len_of_leading_spaces]

class CallStack(Vulnerability):
    def __init__(self, source_map, pcs, calls_affect_state):
        self.source_map = source_map
        self.pcs = self._rm_false_positives(pcs, calls_affect_state)

    def __str__(self):
        return Vulnerability.__str__(self, 'Callstack Depth Attack Vulnerability')

    def _rm_false_positives(self, pcs, calls_affect_state):
        new_pcs = Vulnerability._rm_general_false_positives(self, pcs)
        return self._rm_pcs_not_affect_state(new_pcs, calls_affect_state)

    def _rm_pcs_not_affect_state(self, pcs, calls_affect_state):
        new_pcs = []
        for pc in pcs:
            if pc in calls_affect_state and calls_affect_state[pc] or pc not in calls_affect_state:
                new_pcs.append(pc)
        return new_pcs

class TimeDependency(Vulnerability):
    def __str__(self):
        return Vulnerability.__str__(self, 'Timestamp Dependency')

class Reentrancy(Vulnerability):
    def __str__(self):
        return Vulnerability.__str__(self, 'Re-Entrancy Vulnerability')

class MoneyConcurrency(Vulnerability):
    def __init__(self, source_map, flows):
        self.source_map = source_map
        self.flows = flows

    def is_vulnerable(self):
        return bool(self.flows)

    def __str__(self):
        s = ''
        for idx, pcs in enumerate(self.flows):
            pcs = Vulnerability._rm_general_false_positives(self, pcs)
            s += '\nFlow ' + str(idx + 1) + ':'
            for pc in pcs:
                source_code = self.source_map.find_source_code(pc).split('\n', 1)[0]
                if not source_code:
                    continue
                location = self.source_map.get_location(pc)
                s += '\n%s:%s:%s\n' % (self.source_map.cname, location['begin']['line'] + 1, location['begin']['column'] + 1)
                s += source_code + '\n'
                s += '^'
        return s

class AssertionFailure(Vulnerability):
    def __init__(self, source_map, assertions):
        self.source_map = source_map
        self.assertions = self._reduce_pcs_having_the_same_pos(assertions)

    def _reduce_pcs_having_the_same_pos(self, assertions):
        d = {}
        for asrt in assertions:
            pos = str(self.source_map.instr_positions[asrt.pc])
            if pos not in d:
                d[pos] = asrt
        return d.values()

    def __str__(self):
        s = ''
        for asrt in self.assertions:
            source_code = self.source_map.find_source_code(asrt.pc)

            new_line_idx = source_code.find('\n')
            source_code = source_code.split('\n', 1)[0]
            location = self.source_map.get_location(asrt.pc)

            source = re.sub(self.source_map.root_path, '', self.source_map.get_filename())
            line = location['begin']['line'] + 1
            column = location['begin']['column'] + 1

            s += '%s:%s:%s: Warning: Assertion Failure.\n' % (source, line, column)
            s += source_code
            if new_line_idx != -1:
                s += '\n' + Vulnerability._leading_spaces(self, source_code) + '^\n'
                s += 'Spanning multiple lines.'
            for variable in asrt.model.decls():
                var_name = str(variable)
                if len(var_name.split('-')) > 2:
                    var_name = var_name.split('-')[2]
                if self.source_map.is_a_parameter_or_state_variable(var_name):
                    s += '\n' + var_name + ' = ' + str(asrt.model[variable])
        return s
